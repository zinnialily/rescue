{
 "cells": [
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 1: Import Libraries\n",
    "import osmnx as ox\n",
    "import networkx as nx\n",
    "import random\n",
    "from shapely.geometry import Point\n",
    "import math\n",
    "import numpy as np # Added for potential future numerical operations"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 2: Define Hospital Class\n",
    "class Hospital:\n",
    "    def __init__(self, location, capacity, latlong):\n",
    "        self.location = location  # Node ID in the graph\n",
    "        self.capacity = capacity\n",
    "        self.latlong = latlong # Latitude and longitude coordinates\n",
    "        self.beginning = capacity # Store initial capacity for resetting"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 3: Define Victim Class\n",
    "class Victim:\n",
    "    def __init__(self, location, rating, latlong):\n",
    "        self.location = location  # Node ID in the graph\n",
    "        self.rating = rating      # 'R' (Red/Critical), 'G' (Green), 'U' (Unknown)\n",
    "        self.visited = False      # Flag to track if visited by a vehicle\n",
    "        self.latlong = latlong    # Latitude and longitude coordinates"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 4: Define Vehicle Class\n",
    "class Vehicle:\n",
    "    def __init__(self, vehicle_type, max_risk, location, capacity, index, latlong):\n",
    "        self.type = vehicle_type     # e.g., 'ambulance', 'helicopter', 'rescue_truck'\n",
    "        self.max_risk = max_risk     # Maximum risk level the vehicle can tolerate on a path\n",
    "        self.location = location     # Current node ID in the graph\n",
    "        self.capacity = capacity     # Max number of victims vehicle can carry\n",
    "        self.current_amt = 0         # Current number of victims in the vehicle\n",
    "        self.route = []              # Planned sequence of nodes for the vehicle's route\n",
    "        self.risk_scores = []        # Stores risk scores for segments of the route\n",
    "        self.index = index           # Unique identifier for the vehicle\n",
    "        self.latlong = latlong       # Latitude and longitude coordinates\n",
    "        self.assigned_victims = []   # List of Victim objects assigned to this vehicle"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 5: Helper Function to Get Nearest Node\n",
    "def get_nearest_node(graph, latlong):\n",
    "    \"\"\"Finds the closest node in the OSMnx graph for given latitude and longitude.\"\"\"\n",
    "    point = Point(latlong[1], latlong[0]) # Shapely Point expects (longitude, latitude)\n",
    "    return ox.nearest_nodes(graph, point.x, point.y)"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 6: Vehicle Risk Calculation Function\n",
    "def vehicle_risk(u, v, data, vehicle_type, vehicle_max_risk=5, alpha=0.5, beta=0.5):\n",
    "    \"\"\"Calculates a combined score for traversing an edge based on time and risk.\n",
    "       Returns infinity if the edge's danger exceeds vehicle_max_risk.\n",
    "    \"\"\"\n",
    "    # Default edge speed for general network if 'maxspeed' is not present\n",
    "    # OSMnx automatically imputes missing speeds for 'drive' network_type if speed column not available.\n",
    "    # We'll rely on the 'travel_time' attribute which OSMnx adds if it's not present.\n",
    "    travel_time = data.get('travel_time', 0) # Assumes osmnx has calculated this\n",
    "\n",
    "    # Get danger score from edge data, default to 0 if not present\n",
    "    temp_danger = data.get('danger', 0)\n",
    "\n",
    "    # Check if the edge is traversable based on vehicle's max_risk\n",
    "    if temp_danger > vehicle_max_risk:\n",
    "        return float('inf'), 0, 0  # Not traversable for this vehicle type\n",
    "\n",
    "    # Calculate combined weight (score) for the edge\n",
    "    # The formula can be adjusted based on real-world requirements\n",
    "    combined_weight = alpha * travel_time + beta * temp_danger\n",
    "\n",
    "    return combined_weight, travel_time, temp_danger"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 7: Graph Initialization and Data Generation\n",
    "# Define the bounding box for the operational area\n",
    "# Using (west, south, east, north) for bbox parameter as per OSMnx v2 migration guide\n",
    "bbox_coords = (-95.6, 29.5, -95.2, 29.8) # Roughly Sugar Land, TX area\n\n",
    "# Get a graph of the road network within the bounding box\n",
    "print(\"Downloading graph...\")\n",
    "# G = ox.graph_from_bbox(north, south, east, west, network_type='drive') # Deprecated\n",
    "G = ox.graph_from_bbox(bbox_coords[3], bbox_coords[1], bbox_coords[2], bbox_coords[0], network_type='drive') # Corrected for v2.0.0\n",
    "print(\"Graph downloaded.\")\n\n",
    "# Impute missing travel times (speeds) if not already present\n",
    "G = ox.add_edge_speeds(G)\n",
    "G = ox.add_edge_travel_times(G)\n\n",
    "# Add random danger scores to edges\n",
    "for u, v, k, data in G.edges(keys=True, data=True):\n",
    "    data['danger'] = random.randint(0, 10) # Danger score from 0 to 10\n\n",
    "all_nodes = list(G.nodes())\n\n",
    "# Generate Hospitals\n",
    "num_hospitals = 3\n",
    "hospitals = []\n",
    "print(f\"Generating {num_hospitals} hospitals...\")\n",
    "for i in range(num_hospitals):\n",
    "    # Get random coordinates within the bounding box\n",
    "    rand_lat = random.uniform(bbox_coords[1], bbox_coords[3])\n",
    "    rand_lon = random.uniform(bbox_coords[0], bbox_coords[2])\n",
    "    latlong = (rand_lat, rand_lon)\n",
    "    node = get_nearest_node(G, latlong)\n",
    "    capacity = random.randint(5, 15) # Random capacity between 5 and 15\n",
    "    hospitals.append(Hospital(node, capacity, latlong))\n",
    "    print(f\"  Hospital {i+1}: Node {node}, Capacity {capacity}, LatLong {latlong}\")\n\n",
    "# Generate Victims\n",
    "num_victims = 15\n",
    "victims = []\n",
    "victim_ratings = ['R'] * 3 + ['G'] * 7 + ['U'] * 5 # 3 Red, 7 Green, 5 Unknown\n",
    "random.shuffle(victim_ratings)\n\n",
    "print(f\"Generating {num_victims} victims...\")\n",
    "for i in range(num_victims):\n",
    "    rand_lat = random.uniform(bbox_coords[1], bbox_coords[3])\n",
    "    rand_lon = random.uniform(bbox_coords[0], bbox_coords[2])\n",
    "    latlong = (rand_lat, rand_lon)\n",
    "    node = get_nearest_node(G, latlong)\n",
    "    rating = victim_ratings[i]\n",
    "    victims.append(Victim(node, rating, latlong))\n",
    "    print(f\"  Victim {i+1}: Node {node}, Rating {rating}, LatLong {latlong}\")\n\n",
    "# Generate Vehicles\n",
    "num_vehicles = 4\n",
    "vehicles = []\n",
    "vehicle_types = ['ambulance', 'helicopter', 'rescue_truck'] # Example types\n",
    "type_props = {'ambulance': {'max_risk': 3, 'capacity': 2, 'speed_factor': 1.0}, # Speed factor applied to travel time\n",
    "              'helicopter': {'max_risk': 10, 'capacity': 1, 'speed_factor': 0.5}, # Helicopters ignore roads, faster\n",
    "              'rescue_truck': {'max_risk': 7, 'capacity': 3, 'speed_factor': 0.8}}\n\n",
    "print(f\"Generating {num_vehicles} vehicles...\")\n",
    "for i in range(num_vehicles):\n",
    "    v_type = random.choice(vehicle_types)\n",
    "    props = type_props[v_type]\n",
    "    # Start all vehicles at a random hospital location\n",
    "    start_hospital = random.choice(hospitals)\n",
    "    vehicles.append(Vehicle(v_type, props['max_risk'], start_hospital.location, \n",
    "                            props['capacity'], i, start_hospital.latlong))\n",
    "    print(f\"  Vehicle {i+1}: Type {v_type}, Max Risk {props['max_risk']}, Capacity {props['capacity']}, Start Node {start_hospital.location}\")\n\n",
    "print(\"\\n--- Initialization Complete ---\\n\")"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 8: Pre-calculate Vehicle Matrices (Shortest Paths)\n",
    "vehicle_matrices = {}\n\n",
    "nodes_of_interest = set([v.location for v in victims] + [h.location for h in hospitals] + [veh.location for veh in vehicles])\n",
    "nodes_of_interest = list(nodes_of_interest)\n\n",
    "print(\"Calculating shortest path matrices for each vehicle type...\")\n",
    "for vehicle_type in type_props.keys():\n",
    "    vehicle_info = type_props[vehicle_type]\n",
    "    max_risk_for_type = vehicle_info['max_risk']\n",
    "    speed_factor_for_type = vehicle_info['speed_factor']\n\n",
    "    type_matrix = {'score': {}, 'time': {}, 'risk': {}, 'path': {}}\n\n",
    "    for source_node in nodes_of_interest:\n",
    "        type_matrix['score'][source_node] = {}\n",
    "        type_matrix['time'][source_node] = {}\n",
    "        type_matrix['risk'][source_node] = {}\n",
    "        type_matrix['path'][source_node] = {}\n\n",
    "        for target_node in nodes_of_interest:\n",
    "            if source_node == target_node:\n",
    "                type_matrix['score'][source_node][target_node] = 0\n",
    "                type_matrix['time'][source_node][target_node] = 0\n",
    "                type_matrix['risk'][source_node][target_node] = 0\n",
    "                type_matrix['path'][source_node][target_node] = [source_node]\n",
    "                continue\n\n",
    "            # Use Dijkstra's algorithm to find the shortest path\n",
    "            # The 'weight' parameter here refers to the combined score from vehicle_risk\n",
    "            try:\n",
    "                path = nx.shortest_path(G, source=source_node, target=target_node, \n",
    "                                         weight=lambda u, v, data: vehicle_risk(u, v, data, vehicle_type, max_risk_for_type)[0])\n",
    "                \n",
    "                total_time = 0\n",
    "                total_risk = 0\n",
    "                for i in range(len(path) - 1):\n",
    "                    u, v = path[i], path[i+1]\n",
    "                    # Find the specific edge (handle multi-edges)\n",
    "                    edge_data = G.get_edge_data(u, v)\n",
    "                    # Take the first edge if multiple exist, or iterate if specific logic needed\n",
    "                    edge_key = next(iter(edge_data)) # Get the key of the first edge\n",
    "                    data = edge_data[edge_key]\n",
    "                    \n",
    "                    # Recalculate based on the edge data\n",
    "                    _, time, risk = vehicle_risk(u, v, data, vehicle_type, max_risk_for_type)\n",
    "                    total_time += time\n",
    "                    total_risk += risk\n",
    "                \n",
    "                # Apply speed factor for vehicle type\n",
    "                total_time *= speed_factor_for_type\n",
    "                \n",
    "                # Calculate the final score for the path\n",
    "                # Adjust weights as needed (e.g., risk is more penalizing)\n",
    "                path_score = (total_time / 100) + (0.2 * total_risk)\n",
    "\n",
    "                type_matrix['score'][source_node][target_node] = path_score\n",
    "                type_matrix['time'][source_node][target_node] = total_time\n",
    "                type_matrix['risk'][source_node][target_node] = total_risk\n",
    "                type_matrix['path'][source_node][target_node] = path\n",
    "            except nx.NetworkXNoPath:\n",
    "                # No path exists or path involves edges exceeding max_risk\n",
    "                type_matrix['score'][source_node][target_node] = float('inf')\n",
    "                type_matrix['time'][source_node][target_node] = float('inf')\n",
    "                type_matrix['risk'][source_node][target_node] = float('inf')\n",
    "                type_matrix['path'][source_node][target_node] = []\n",
    "            except Exception as e:\n",
    "                print(f\"Error calculating path for {vehicle_type} from {source_node} to {target_node}: {e}\")\n",
    "                type_matrix['score'][source_node][target_node] = float('inf')\n",
    "                type_matrix['time'][source_node][target_node] = float('inf')\n",
    "                type_matrix['risk'][source_node][target_node] = float('inf')\n",
    "                type_matrix['path'][source_node][target_node] = []\n\n",
    "    vehicle_matrices[vehicle_type] = type_matrix\n",
    "    print(f\"  Matrix for {vehicle_type} complete.\")\n\n",
    "print(\"\\n--- Path Matrix Calculation Complete ---\\n\")"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 9: Calculate Total Score Function\n",
    "def calculate_total_score(current_vehicles, victims_list, hospitals_list, vehicle_matrices):\n",
    "    \"\"\"Calculates the total score for a given state (vehicle assignments and routes).\n",
    "    Lower score is better.\n",
    "    \"\"\"\n",
    "    total_score = 0\n",
    "    visited_victims_count = 0\n",
    "    # Reset capacities for calculation\n",
    "    for h in hospitals_list:\n",
    "        h.capacity = h.beginning\n",
    "    for v in current_vehicles:\n",
    "        v.current_amt = 0\n",
    "        v.route = [] # Clear route before recalculating\n",
    "        v.risk_scores = []\n",
    "    for vic in victims_list:\n",
    "        vic.visited = False\n\n",
    "    # Assign victims to vehicles and build routes based on assigned_victims\n",
    "    for vehicle in current_vehicles:\n",
    "        current_loc = vehicle.location # Vehicle's starting location\n",
    "        vehicle_type = vehicle.type\n",
    "        \n",
    "        # Sort assigned victims by rating to prioritize 'R' first (Red, then Unknown, then Green)\n",
    "        # If ratings are equal, order doesn't strictly matter for initial assignment, but path order might.\n",
    "        # For now, we'll process them in the order they were assigned during neighbor generation, which should be fine.\n",
    "        # The scoring mechanism heavily penalizes unvisited 'R' victims.\n\n",
    "        vehicle_path_score = 0\n",
    "        path_segments = [] # To store (source, target) for route construction\n\n",
    "        # First, ensure red victims are processed as highest priority\n",
    "        red_victims_assigned = [v for v in vehicle.assigned_victims if v.rating == 'R']\n",
    "        other_victims_assigned = [v for v in vehicle.assigned_victims if v.rating != 'R']\n",
    "        \n",
    "        # Prioritize red victims first, then others\n",
    "        sorted_assigned_victims = red_victims_assigned + other_victims_assigned\n",
    "        \n",
    "        # Create a copy to iterate, allowing modification of original list if needed (though not done here)\n",
    "        assigned_victims_copy = list(sorted_assigned_victims)\n\n",
    "        for victim in assigned_victims_copy:\n",
    "            if vehicle.current_amt < vehicle.capacity:\n",
    "                try:\n",
    "                    path_score = vehicle_matrices[vehicle_type]['score'][current_loc][victim.location]\n",
    "                    travel_time = vehicle_matrices[vehicle_type]['time'][current_loc][victim.location]\n",
    "                    risk_taken = vehicle_matrices[vehicle_type]['risk'][current_loc][victim.location]\n",
    "                    path_nodes = vehicle_matrices[vehicle_type]['path'][current_loc][victim.location]\n",
    "                    \n",
    "                    if math.isinf(path_score): # Check if path is inaccessible\n",
    "                        # If a path is inaccessible, this assignment is invalid, penalize heavily\n",
    "                        total_score += float('inf')\n",
    "                        continue # Skip to next vehicle or victim\n\n",
    "                    vehicle_path_score += path_score\n",
    "                    vehicle.current_amt += 1\n",
    "                    victim.visited = True\n",
    "                    visited_victims_count += 1\n",
    "                    \n",
    "                    # Add cost for victim rating based on travel time\n",
    "                    if victim.rating == 'R':\n",
    "                        vehicle_path_score += 0.5 * travel_time # Higher penalty for critical victims\n",
    "                    elif victim.rating == 'U':\n",
    "                        vehicle_path_score += 0.2 * travel_time # Medium penalty for unknown victims\n",
    "                    \n",
    "                    # Extend vehicle's route and risk scores\n",
    "                    if not vehicle.route: # If this is the first segment, include current_loc\n",
    "                        vehicle.route.extend(path_nodes)\n",
    "                    else:\n",
    "                        vehicle.route.extend(path_nodes[1:]) # Append from second node to avoid duplication\n",
    "                    vehicle.risk_scores.append(risk_taken)\n",
    "                    \n",
    "                    current_loc = victim.location # Update current location for next segment\n",
    "                except KeyError:\n",
    "                    # This can happen if a node is isolated or an assignment is invalid\n",
    "                    total_score += float('inf')\n",
    "                    continue\n",
    "            else: # Vehicle is full, must go to hospital\n",
    "                # Find nearest hospital with capacity\n",
    "                best_hospital = None\n",
    "                min_hospital_score = float('inf')\n",
    "                for h in hospitals_list:\n",
    "                    if h.capacity > 0:\n",
    "                        try:\n",
    "                            hospital_score = vehicle_matrices[vehicle_type]['score'][current_loc][h.location]\n",
    "                            if hospital_score < min_hospital_score:\n",
    "                                min_hospital_score = hospital_score\n",
    "                                best_hospital = h\n",
    "                        except KeyError:\n",
    "                            pass # No path to this hospital\n",
    "                \n",
    "                if best_hospital:\n",
    "                    hospital_path_score = vehicle_matrices[vehicle_type]['score'][current_loc][best_hospital.location]\n",
    "                    hospital_path_nodes = vehicle_matrices[vehicle_type]['path'][current_loc][best_hospital.location]\n",
    "                    hospital_risk_taken = vehicle_matrices[vehicle_type]['risk'][current_loc][best_hospital.location]\n\n",
    "                    vehicle_path_score += hospital_path_score\n",
    "                    best_hospital.capacity -= vehicle.current_amt # Drop off all victims\n",
    "                    vehicle.current_amt = 0 # Vehicle is now empty\n",
    "                    \n",
    "                    if not vehicle.route:\n",
    "                        vehicle.route.extend(hospital_path_nodes)\n",
    "                    else:\n",
    "                        vehicle.route.extend(hospital_path_nodes[1:])\n",
    "                    vehicle.risk_scores.append(hospital_risk_taken)\n",
    "                    current_loc = best_hospital.location # Vehicle is now at hospital\n    \n    # After visiting victims and potentially going to a hospital, \n    # if the vehicle has victims, it must drop them off.\n    # If the vehicle has visited victims and is not at a hospital, route to nearest hospital.\n    if vehicle.current_amt > 0: # Vehicle still has victims\n        best_hospital = None\n        min_hospital_score = float('inf')\n        for h in hospitals_list:\n            if h.capacity > 0: # Ensure hospital has capacity\n                try:\n                    hospital_score = vehicle_matrices[vehicle_type]['score'][current_loc][h.location]\n                    if hospital_score < min_hospital_score:\n                        min_hospital_score = hospital_score\n                        best_hospital = h\n                except KeyError:\n                    pass\n        \n        if best_hospital:\n            hospital_path_score = vehicle_matrices[vehicle_type]['score'][current_loc][best_hospital.location]\n            hospital_path_nodes = vehicle_matrices[vehicle_type]['path'][current_loc][best_hospital.location]\n            hospital_risk_taken = vehicle_matrices[vehicle_type]['risk'][current_loc][best_hospital.location]\n\n            vehicle_path_score += hospital_path_score\n            best_hospital.capacity -= vehicle.current_amt\n            vehicle.current_amt = 0\n            \n            if not vehicle.route:\n                vehicle.route.extend(hospital_path_nodes)\n            else:\n                vehicle.route.extend(hospital_path_nodes[1:])\n            vehicle.risk_scores.append(hospital_risk_taken)\n            current_loc = best_hospital.location\n        else:\n            # No hospital with capacity found, penalize heavily\n            vehicle_path_score += float('inf')\n\n    # Add vehicle's total path score to the overall total\n    total_score += vehicle_path_score\n\n    # Penalize unvisited 'Red' victims most heavily\n    for vic in victims_list:\n        if vic.rating == 'R' and not vic.visited:\n            total_score += 5000 # High penalty for unvisited critical victims\n\n    return total_score"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 10: Generate Neighbor Function (for Simulated Annealing)\n",
    "def get_neighbor(current_vehicles, victims_list, hospitals_list, vehicle_matrices):\n",
    "    \"\"\"Generates a new neighboring solution by slightly modifying the current one.\n",
    "       This involves reassigning victims or swapping assignments between vehicles.\n",
    "    \"\"\"\n",
    "    # Create deep copies to avoid modifying the original solution directly\n",
    "    new_vehicles = []\n",
    "    for v in current_vehicles:\n",
    "        new_vehicle = Vehicle(v.type, v.max_risk, v.location, v.capacity, v.index, v.latlong)\n",
    "        # Deep copy assigned_victims - ensure it's a list of new Victim objects\n",
    "        new_vehicle.assigned_victims = []\n",
    "        for old_victim in v.assigned_victims:\n",
    "            new_victim_copy = Victim(old_victim.location, old_victim.rating, old_victim.latlong)\n",
    "            new_vehicle.assigned_victims.append(new_victim_copy)\n",
    "        new_vehicles.append(new_vehicle)\n\n",
    "    new_victims = []\n",
    "    victim_map = {vic.location: vic for vic in victims_list} # Map victim node to victim object\n",
    "    for vic in victims_list:\n",
    "        new_victims.append(Victim(vic.location, vic.rating, vic.latlong))\n\n",
    "    new_hospitals = []\n",
    "    for h in hospitals_list:\n",
    "        new_hospitals.append(Hospital(h.location, h.capacity, h.latlong))\n\n",
    "    # --- Perturbation Logic ---\n",
    "    action = random.choice(['swap_victims_between_vehicles', 'move_victim_to_vehicle', 'swap_vehicle_assignments'])\n\n",
    "    if action == 'swap_victims_between_vehicles' and len(new_vehicles) >= 2:\n",
    "        # Attempt to swap victims between two randomly chosen vehicles\n",
    "        v1, v2 = random.sample(new_vehicles, 2)\n",
    "        if v1.assigned_victims and v2.assigned_victims:\n",
    "            vic1_idx = random.randrange(len(v1.assigned_victims))\n",
    "            vic2_idx = random.randrange(len(v2.assigned_victims))\n",
    "            \n",
    "            # Swap the victim objects directly (they are copies)\n",
    "            temp_vic = v1.assigned_victims[vic1_idx]\n",
    "            v1.assigned_victims[vic1_idx] = v2.assigned_victims[vic2_idx]\n",
    "            v2.assigned_victims[vic2_idx] = temp_vic\n\n",
    "    elif action == 'move_victim_to_vehicle' and new_victims and new_vehicles:\n",
    "        # Attempt to move a random unassigned victim to a random vehicle, or reassign an assigned one\n",
    "        target_victim = random.choice(new_victims)\n",
    "        target_vehicle = random.choice(new_vehicles)\n",
    "        \n",
    "        # Remove victim from its current assignment if it's already assigned\n",
    "        for v in new_vehicles:\n",
    "            if target_victim in v.assigned_victims:\n",
    "                v.assigned_victims.remove(target_victim)\n",
    "                break\n",
    "        \n",
    "        # Assign victim to the new vehicle\n",
    "        target_vehicle.assigned_victims.append(target_victim)\n\n",
    "    elif action == 'swap_vehicle_assignments' and new_victims and len(new_vehicles) >= 2:\n",
    "        # Pick two random victims and try to assign them to two random vehicles (possibly same)\n",
    "        vic_to_assign1 = random.choice(new_victims)\n",
    "        vic_to_assign2 = random.choice(new_victims)\n",
    "        veh1, veh2 = random.sample(new_vehicles, 2)\n\n",
    "        # Remove victims from their current assignments\n",
    "        for v in new_vehicles:\n",
    "            if vic_to_assign1 in v.assigned_victims:\n",
    "                v.assigned_victims.remove(vic_to_assign1)\n",
    "            if vic_to_assign2 in v.assigned_victims:\n",
    "                v.assigned_victims.remove(vic_to_assign2)\n",
    "        \n",
    "        # Assign them to the new vehicles\n",
    "        veh1.assigned_victims.append(vic_to_assign1)\n",
    "        veh2.assigned_victims.append(vic_to_assign2)\n\n",
    "    # IMPORTANT: Ensure 'R' (Red) victims are always assigned if possible.\n",
    "    # This logic can be more sophisticated (e.g., ensure they are assigned first in a route).\n",
    "    # For simplicity here, we'll just check if any 'R' victims are unassigned and assign them to a random available vehicle.\n",
    "    assigned_victim_locations = set()\n",
    "    for v in new_vehicles:\n",
    "        assigned_victim_locations.update([vic.location for vic in v.assigned_victims])\n",
    "    \n",
    "    unassigned_red_victims = [vic for vic in new_victims if vic.rating == 'R' and vic.location not in assigned_victim_locations]\n",
    "    \n",
    "    for red_vic in unassigned_red_victims:\n",
    "        if new_vehicles:\n",
    "            # Assign to a random vehicle, preferably one that can handle it\n",
    "            # A more intelligent assignment might pick the closest vehicle or least loaded\n",
    "            chosen_vehicle = random.choice(new_vehicles)\n",
    "            chosen_vehicle.assigned_victims.append(red_vic)\n",
    "            assigned_victim_locations.add(red_vic.location)\n\n",
    "    # --- Route Re-construction and Validation (Simplified) ---\n",
    "    # The actual paths and scores will be recalculated in calculate_total_score\n",
    "    # Here, we mainly update the assigned_victims list for each vehicle.\n",
    "    # Sort assigned victims within each vehicle: prioritize 'R' victims, then others.\n",
    "    for vehicle in new_vehicles:\n",
    "        red_vics = sorted([v for v in vehicle.assigned_victims if v.rating == 'R'], \n",
    "                          key=lambda x: vehicle_matrices[vehicle.type]['score'].get(vehicle.location, {}).get(x.location, float('inf')))\n",
    "        other_vics = sorted([v for v in vehicle.assigned_victims if v.rating != 'R'], \n",
    "                            key=lambda x: vehicle_matrices[vehicle.type]['score'].get(vehicle.location, {}).get(x.location, float('inf')))\n",
    "        vehicle.assigned_victims = red_vics + other_vics # Red victims first\n\n",
    "    return new_vehicles, new_victims, new_hospitals # Return modified copies"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 11: Simulated Annealing Algorithm\n",
    "def simulated_annealing(vehicles_initial, victims_list, hospitals_list, vehicle_matrices, \n",
    "                        initial_temperature, cooling_rate, iterations):\n",
    "    \"\"\"Implements the simulated annealing metaheuristic for optimization.\"\"\"\n",
    "    \n",
    "    # Make initial deep copies for the algorithm to work with\n",
    "    current_vehicles = []\n",
    "    for v in vehicles_initial:\n",
    "        new_vehicle = Vehicle(v.type, v.max_risk, v.location, v.capacity, v.index, v.latlong)\n",
    "        # No assigned victims yet for initial state, will be assigned by get_neighbor if it takes all victims\n",
    "        current_vehicles.append(new_vehicle)\n\n",
    "    current_victims = []\n",
    "    for vic in victims_list:\n",
    "        current_victims.append(Victim(vic.location, vic.rating, vic.latlong))\n\n",
    "    current_hospitals = []\n",
    "    for h in hospitals_list:\n",
    "        current_hospitals.append(Hospital(h.location, h.capacity, h.latlong))\n\n",
    "    # Initialize 'current_solution' to a random valid assignment first\n",
    "    # This is a crucial step for SA - ensure the initial solution is reasonably valid.\n",
    "    # Simple initial assignment: distribute victims round-robin or based on proximity\n",
    "    # For now, we'll rely on `get_neighbor` to generate a sensible first state from a 'blank' initial state.\n\n",
    "    # Start with a random initial assignment for the 'current_solution'\n",
    "    temp_current_vehicles, temp_current_victims, temp_current_hospitals = \n",
    "        get_neighbor(current_vehicles, current_victims, current_hospitals, vehicle_matrices)\n",
    "    \n",
    "    # Distribute all victims initially to get a starting point\n",
    "    unassigned_vics = list(temp_current_victims) # All victims are initially unassigned in this context\n",
    "    random.shuffle(unassigned_vics)\n",
    "    \n",
    "    for i, vic in enumerate(unassigned_vics):\n",
    "        if temp_current_vehicles:\n",
    "            # Assign to vehicles in a round-robin fashion\n",
    "            assigned_vehicle_idx = i % len(temp_current_vehicles)\n",
    "            temp_current_vehicles[assigned_vehicle_idx].assigned_victims.append(vic)\n",
    "\n",
    "    current_vehicles = temp_current_vehicles\n",
    "    current_victims = temp_current_victims\n",
    "    current_hospitals = temp_current_hospitals\n\n",
    "    current_score = calculate_total_score(current_vehicles, current_victims, current_hospitals, vehicle_matrices)\n",
    "    best_score = current_score\n",
    "    best_vehicles = current_vehicles\n",
    "    best_victims = current_victims # Store victims state associated with best vehicles\n    \n    temperature = initial_temperature\n\n",
    "    print(\"Starting Simulated Annealing...\")\n",
    "    print(f\"Initial Score: {current_score:.2f}\")\n\n",
    "    for i in range(iterations):\n",
    "        # Generate a neighbor solution\n",
    "        neighbor_vehicles, neighbor_victims, neighbor_hospitals = \\\n",
    "            get_neighbor(current_vehicles, victims_list, hospitals_list, vehicle_matrices)\n",
    "        \n",
    "        neighbor_score = calculate_total_score(neighbor_vehicles, neighbor_victims, neighbor_hospitals, vehicle_matrices)\n\n",
    "        # Calculate energy difference\n",
    "        delta_e = neighbor_score - current_score\n",
    "        \n",
    "        # Acceptance probability\n",
    "        if delta_e < 0 or (temperature > 0 and random.uniform(0, 1) < math.exp(-delta_e / temperature)):\n",
    "            current_score = neighbor_score\n",
    "            current_vehicles = neighbor_vehicles\n",
    "            current_victims = neighbor_victims\n",
    "            current_hospitals = neighbor_hospitals\n",
    "            \n",
    "            if current_score < best_score:\n",
    "                best_score = current_score\n",
    "                best_vehicles = current_vehicles # Store the vehicles for the best solution\n",
    "                best_victims = current_victims # Store victims state for consistency\n\n",
    "        # Cool down the temperature\n",
    "        temperature *= cooling_rate\n",
    "        \n",
    "        if i % (iterations // 10) == 0: # Print progress every 10% of iterations\n",
    "            print(f\"Iteration {i}/{iterations}, Temp: {temperature:.2f}, Current Score: {current_score:.2f}, Best Score: {best_score:.2f}\")\n",
    "        \n",
    "        if temperature < 1e-5: # Stop if temperature gets too low\n",
    "            print(f\"Temperature too low, stopping at iteration {i}\")\n",
    "            break\n\n",
    "    print(\"\\nSimulated Annealing Finished.\")\n",
    "    print(f\"Final Best Score: {best_score:.2f}\")\n    \n    # Recalculate the route and visited status for the best solution before returning\n    # This ensures the returned 'best_vehicles' has its 'route', 'risk_scores', 'current_amt' \n    # and associated 'best_victims' have their 'visited' status correctly set.\n    final_score = calculate_total_score(best_vehicles, best_victims, hospitals_list, vehicle_matrices)\n\n",
    "    return best_score, best_vehicles"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 12: Execute Simulated Annealing\n",
    "# Ensure 'vehicles', 'victims', 'hospitals', and 'vehicle_matrices' are defined from previous cells.\n\n",
    "initial_temp = 100\n",
    "cooling_rate = 0.95\n",
    "num_iterations = 10000\n\n",
    "final_best_score, final_best_vehicles = simulated_annealing(\n",
    "    vehicles,\n",
    "    victims,\n",
    "    hospitals,\n",
    "    vehicle_matrices,\n",
    "    initial_temp,\n",
    "    cooling_rate,\n",
    "    num_iterations\n",
    ")\n\n",
    "print(\"\\n--- Optimized Solution Details ---\")\n",
    "print(f\"Total Score: {final_best_score:.2f}\")\n",
    "for i, vehicle in enumerate(final_best_vehicles):\n",
    "    print(f\"\\nVehicle {vehicle.index} ({vehicle.type}):\")\n",
    "    if vehicle.assigned_victims:\n",
    "        print(f\"  Assigned Victims: {[f'Victim at {v.location} ({v.rating})' for v in vehicle.assigned_victims]}\")\n",
    "        print(f\"  Route (nodes): {vehicle.route}\")\n",
    "        print(f\"  Risk Scores (per segment): {vehicle.risk_scores}\")\n",
    "    else:\n",
    "        print(\"  No victims assigned.\")\n\n",
    "# You might want to add plotting code here to visualize the routes on the map\n",
    "# Example (requires matplotlib, which is already imported by osmnx):\n",
    "# fig, ax = ox.plot_graph_routes(G, [v.route for v in final_best_vehicles if v.route], \n",
    "#                                route_colors=['r', 'g', 'b', 'y'], route_linewidth=2, \n",
    "#                                node_size=0, bgcolor='k')\n",
    "# for h in hospitals:\n",
    "#     ax.scatter(G.nodes[h.location]['x'], G.nodes[h.location]['y'], color='blue', marker='s', s=100, label='Hospital')\n",
    "# for v in victims:\n",
    "#     color = 'red' if v.rating == 'R' else ('orange' if v.rating == 'U' else 'green')\n",
    "#     ax.scatter(G.nodes[v.location]['x'], G.nodes[v.location]['y'], color=color, marker='o', s=50, label=f'Victim ({v.rating})')\n",
    "# plt.show()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
